<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />

  <title>Introduction to Constraint Programming</title>

  <meta name="description" content="A gentle introduction to Constraint Programming" />
  <meta name="author" content="Cyril Delmas" />

  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" href="css/reset.css" />
  <link rel="stylesheet" href="css/reveal.css" />
  <link rel="stylesheet" href="css/theme/simple.css" id="theme" />

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/monokai.css" />

  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi)
      ? 'css/print/pdf.css'
      : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
  </script>

  <!--[if lt IE 9]>
      <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
  <!-- [BODY] begining of presentation -->

  <div class="reveal">
    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
      <section>
        <h1>Programmation par contraintes</h1>
        <h3>Introduction</h3>
        <p>
          <small>Cyril Delmas</small>
        </p>
      </section>

      <section>
        <section>
          <h2>Qui suis-je?</h2>
        </section>
        <section>
          <p>
            <img src="images/me.jpg" style="vertical-align: left; border: 0" height="80" width="80" />
          </p>
          <p>
            <ul>
              <li>Senior Backend Engineer @blue_valet</li>
              <li><img src="images/twitter.png" style="vertical-align: middle; border: 0" height="40" width="40" />
                @cyril_delmas</li>
              <li><img src="images/github.png" style="vertical-align: middle; border: 0" height="40" width="40" />
                cdelmas</li>
            </ul>
          </p>
        </section>
        <section>
          <img src="images/blue-valet.png" style="vertical-align: middle; border: 0" />
          <aside class="notes">
            <ul>
              <li>Service de voiturier en gares et a√©roports</li>
              <li>Pr√©sent en France, Espagne et Portugal</li>
            </ul>
          </aside>
        </section>
      </section>

      <section>
        <section>
          <h2>Agenda</h2>
        </section>
        <section>
          <ol>
            <li>D√©finitions</li>
            <li>Exemples</li>
            <li>Fonctionnement d'un solveur (si on a le temps)</li>
            <li>Techniques et patterns</li>
            <li>Questions (m√™me s'il n'y en a jamais ü§î)</li>
          </ol>
        </section>
      </section>

      <section>
        <section>
          <h2>D√©finitions</h2>
        </section>
        <section>
          <dl>
            <dt>Contrainte</dt>
            <dd>Relation logique entre plusieurs <em>variables</em></dd>
          </dl>
          <br />
          <br />
          <code>X &lt; Y</code>
        </section>
        <section>
          <dl>
            <dt>Variable</dt>
            <dd>Inconnue (au sens math√©matique) pouvant prendre une valeur dans un <em>domaine</em> donn√©.</dd>
          </dl>
          <br />
          <br />
          <code>X, Y, Z, T</code>
        </section>
        <section>
          <dl>
            <dt>Domaine</dt>
            <dd>Ensemble des valeurs que peut prendre une inconnue. Un domaine peut √™tre born√© ou non, et discret ou
              continu.</dd>
          </dl>
          <br />
          <br />
          <code>‚Ñï, ‚Ñ§, {0, 1}, [0, 100]</code>
          <aside class="notes">
            [0,100] est born√©, ‚Ñï ne l'est pas.
            ‚Ñï est discret, [0, 100] est continu si on consid√®re les nombres r√©els de l'intervalle.
          </aside>
        </section>
        <section>
          <dl>
            <dt>Programmation par contraintes</dt>
            <dd>M√©thode de mod√©lisation et r√©solution de probl√®mes combinatoires sous la forme de probl√®mes de
              satisfaction de contraintes.</dd>
          </dl>
          <br />
          <br />
          <code>P = ((V<sub>1</sub>,..,V<sub>k</sub>) ‚àà D<sub>1</sub>√ó..√óD<sub>k</sub>, {C<sub>1</sub>,...,C<sub>n</sub>})</code>
        </section>
        <section>
          <p>R√©soudre un probl√®me de satisfaction de contraintes</p>
          <h2>=</h2>
          <p>donner une valeur √† chaque inconnue du probl√®me, en respectant les relations logiques.</p>
          <h2>‚Üì</h2>
          <p>On obtient une solution.</p>
          <aside class="notes">
            domaine discret, techniques = recherche et combinaisons ; domaine infini, technique = m√©thodes alg√©briques
            et num√©riques
            <br />
            Suivant le type de probl√®me, une solution r√©alisable n'est pas forc√©ment bonne. Si on souhaite donner un
            score √† une solution, on doit d√©terminer un objectif.
          </aside>
        </section>
        <section>
          <h3>Evaluation d'une solution</h3>
          <p>On peut donner un score √† une solution, en donnant un ou plusieurs objectifs =
            <code>f(V<sub>1</sub>,..,V<sub>k</sub>)</code></p>
          <p>Exemple classique : minimiser un co√ªt</p>
        </section>
        <section>
          <h3>Pas de solution = probl√®me <em>sur-contraint</em></h3>
          <p>On doit relaxer quelques contraintes pour obtenir une solution</p>
          <ul>
            <li>En hi√©rarchisant les contraintes (requises, optionnelles, ...)</li>
            <li>En attribuant des poids, et en le maximisant</li>
            <li>En appliquant des coefficients al√©atoires (fuzzy)</li>
          </ul>
        </section>
      </section>
      <section>
        <img src="images/whaaat.gif" style="vertical-align: middle; border: 0" />
      </section>
      <section>
        <section>
          <h2>Exemples expliqu√©s</h2>
        </section>
        <section>
          <h3>Probl√®me n¬∞1 : Pythagore</h3>
          <p>Trouver tous les triangles rectangles de p√©rim√®tre inf√©rieur √† 200.</p>
        </section>
        <section>
          <h3>Solution</h3>
          <img src="images/triangle.png" width="400" height="400"
            style="float: left; vertical-align: middle; border: 0" />
          <div style="overflow: hidden; padding-left: 50px">
            <p>Th√©or√®me de Pythagore :<br /> <code>c<sup>2</sup> = a<sup>2</sup> + b<sup>2</sup></code></p>
            <p>Contrainte de p√©rim√®tre : <br /> <code>a + b + c ‚â§ 200</code></p>
            <p>Quel domaine pour les variables ?</p>
          </div>
        </section>
        <section>
          <h3>Probl√®me n¬∞2 : Pythagore bis</h3>
          <p>Trouver le triangle rectangle de p√©rim√®tre inf√©rieur √† 200 ayant la plus grande aire.</p>
        </section>
        <section>
          <h3>Solution</h3>
          <p>On reprend le mod√®le pr√©c√©dent, et on y ajoute une variable sur laquelle on va calculer un objectif</p>
          <p><code>maximize(area)</code></p>
        </section>
        <section>
          <h3>Probl√®me n¬∞3 : Sudoku</h3>
          <img src="images/sudoku.png" width="400" height="400"
            style="float: left; vertical-align: middle; border: 0" />
          <div style="overflow: hidden; padding-left: 50px">
            <p>R√©soudre un sudoku de niveau diabolique.</p>
          </div>
        </section>
        <section>
          <h3>Solution</h3>
          <p>
            <ul>
              <li>Chaque case du tableau est une variable, de domaine <code>{1,2,..,9}</code></li>
              <li>Les cases d√©j√† remplies ont un domaine singleton (de la valeur donn√©e)</li>
              <li>Les chiffres d'une m√™me colonne sont tous diff√©rents</li>
              <li>Les chiffres d'une m√™me ligne sont tous diff√©rents</li>
              <li>Les chiffres d'une m√™me r√©gion sont tous diff√©rents</li>
            </ul>
          </p>
        </section>
      </section>
      <section>
        <section>
          <h2>Fonctionnement d'un solveur</h2>
          <p>Cas des probl√®mes √† variables √† domaine fini et discret</p>
        </section>
        <section>
          <p>Basiquement, construction et parcours d'un arbre de combinaisons</p>
          <aside class="notes">
            Probl√®me principal : le nb de combinaisons invalides qu'on doit ignorer
          </aside>
        </section>
        <section>
          <h2>Recherche syst√©matique</h2>
          <ul>
            <li>Generate and Test</li>
            <li>Backtracking</li>
            <aside class="notes">
              G√©n√©ration d'une solution, et test des contraintes, etc.<br />
              Probl√®me : certes exhaustif (on est s√ªr de trouver une solution si elle existe), mais tr√®s peu
              efficient<br />
              Recherche incr√©mentale, en choisissant des valeurs consistantes avec celles des variables d√©j√† valu√©es. Si
              une valeur n'est pas consistante, on revient en arri√®re dans l'arbre.<br />
              Probl√®mes: √©checs r√©p√©t√©s pour les m√™mes raisons (pas d'identification des causes d'un √©chec), travail
              redondant (pas de m√©morisation des conflits), d√©tection des conflits trop tard (quand ils se
              produisent).<br />
              Il existe plein d'algorithmes de backtracking (AC-3, AC-6, ...)
            </aside>
          </ul>
        </section>
        <section>
          <h3>Techniques de consistance</h3>
          <p>Consistance locale (n≈ìud, arc, k-path, ...)</p>
          <aside class="notes">But : r√©duire l'espace de recherche; exemple n≈ìud : X est pair -> on √©limine tous les
            nombres impairs de D</aside>
        </section>
        <section>
          <h3>Propagation des contraintes</h3>
          <p>Il s'agit d'utiliser les techniques de consistance, dans un algorithme de backtracking</p>
          <ul>
            <li>Forward checking</li>
            <li>Look ahead (aka MAC - maintaining arc-consistency)</li>
            <aside class="notes">
              * Recherche d'arc-consistance √† partir de la variable courant uniquement, sur des variables non-valu√©es.
              Si on d√©tecte un conflit, on retire temporairement la valeur du domaine. Si tous les domaines sont vides,
              on revient en arri√®re sur la variable s√©lectionn√©e.<br />
              * Forward checking, mais en appliquant une v√©rification d'arc-consistance compl√®te (permet alors de
              d√©truire toute une branche de l'arbre de recherche).
            </aside>
          </ul>
        </section>
        <section>
          <h3>Ordonnancement du choix des variables et des valeurs</h3>
          <p>Utilisation d'heuristiques : "first fail" pour les variables, "first succeed" pour la valeur</p>
          <aside class="notes">
            En ordonnant les assignations et donc les v√©rifications de consistance, on peut gagner beaucoup de temps en
            construisant un arbre plus restreint.<br />
            First fail -> permet d'√©liminer des branches de l'arbre l√† o√π on pense qu'on va √©chouer.
            First succeed -> permet de tenter de trouver une solution l√† o√π on pense que l'affectation d'une telle
            valeur peut r√©ussir.
          </aside>
        </section>
        <section>
          <h3>R√©duction de l'arbre de recherche</h3>
          <ul>
            <li>Th√©orie des graphes</li>
            <li>Elimination du backtrack en ordonnant les n≈ìuds du graphe</li>
          </ul>
        </section>
        <section>
          <h2>Algorithmes heuristiques et stochastiques</h2>
          <ul>
            <li>Hill-climbing</li>
            <li>Min-conflicts</li>
            <li>Tabu search</li>
            <li>...</li>
          </ul>
          <aside class="notes">
            Ce sont des algo de recherche locale : une solution est g√©n√©r√©e localement, et les algorithmes tentent de
            r√©parer la solution en solution valide<br />
            Pas d'assurance de compl√©tude, mais possibilit√© de trouver une solution acceptable plus rapidement.
          </aside>
        </section>

      </section>
      <section>
        <section>
          <h2>Techniques et patterns</h2>
        </section>
        <section>
          <dl>
            <dt>Quand utiliser la programmation par contraintes ?</dt>
            <dd>
              <ul>
                <li>Contraintes complexes et nombreuses</li>
                <li>Probl√®mes avec fonction objective simple</li>
                <li>Probl√®mes de d√©cisions</li>
                <li>Probl√®mes issus des domains o√π cela fonctionne classiquement</li>
              </ul>
            </dd>
          </dl>
        </section>
        <section>
          <h3>Domaines d'application</h3>
          <ul>
            <li>Planning de conf√©rence</li>
            <li>Parcours de livraison</li>
            <li>Assignation de t√¢ches</li>
            <li>S√©quen√ßage d'ADN</li>
            <li>Localisation de pannes</li>
            <li>Design de circuits</li>
          </ul>
        </section>
        <section>
          <dl>
            <dt>Comment faire ?</dt>
            <dd>
              <ol>
                <li>Identifier les variables du probl√®mes</li>
                <li>Attribuer un domaine aux variables -> taille du probl√®me</li>
                <li>Etablir la liste exhaustive des contraintes</li>
                <li>Utiliser un algorithme na√Øf en premier (<em>Premature optimization...</em>), mesurer les
                  performances</li>
                <li>Optimiser si besoin (temps, qualit√© des solutions) en changeant d'algorithme</li>
              </ol>
            </dd>
          </dl>
          <aside class="notes">
            Pensez √† la binarisation des contraintes (th√©or√®me).
          </aside>
        </section>
      </section>

      <section>
        <img src="images/questions.png" style="vertical-align: middle; border: 0" />
      </section>

      <section>
        <h2>Liens utiles</h2>
        <ul>
          <li>http://ktiml.mff.cuni.cz/~bartak/constraints/</li>
          <aside class="notes">Guide en ligne, Roman Bartak</aside>
          <li>les documentations de choco-solver, optaplanner, OscaR, ...</li>
          <li>http://www.hakank.org/constraint_programming_blog/</li>
          <li>https://sofdem.github.io/gccat/gccat/sec5.html</li>
          <aside class="notes">Global constraints catalog</aside>
        </ul>
      </section>

      <section>
        <h2>Merci</h2>
        <img src="images/thank_you.gif" />
      </section>
    </div>
  </div>

  <!-- [BODY] end of presentation -->

  <script src="js/reveal.js"></script>

  <script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      center: true,
      hash: true,

      transition: 'slide', // none/fade/slide/convex/concave/zoom

      // More info https://github.com/hakimel/reveal.js#dependencies
      dependencies: [
        {
          src: 'plugin/markdown/marked.js',
          condition: function () {
            return !!document.querySelector('[data-markdown]');
          }
        },
        {
          src: 'plugin/markdown/markdown.js',
          condition: function () {
            return !!document.querySelector('[data-markdown]');
          }
        },
        { src: 'plugin/highlight/highlight.js', async: true },
        { src: 'plugin/search/search.js', async: true },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true }
      ]
    });
  </script>
</body>

</html>